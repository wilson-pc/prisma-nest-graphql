# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AggregateRole {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Int!
}

input DateTimeFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: Timestamp
  notIn: [Timestamp!]
}

type Mutation {
  createRole(data: RoleCreateInput!): Role!
  createUser(data: UserCreateInput!): User!
  deleteManyRole(where: RoleWhereInput): BatchPayload!
  deleteManyUser(where: UserWhereInput): BatchPayload!
  deleteRole(where: RoleWhereUniqueInput!): Role
  deleteUser(where: UserWhereUniqueInput!): User
  updateManyRole(data: RoleUpdateManyMutationInput!, where: RoleWhereInput): BatchPayload!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateRole(data: RoleUpdateInput!, where: RoleWhereUniqueInput!): Role
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertRole(create: RoleCreateInput!, update: RoleUpdateInput!, where: RoleWhereUniqueInput!): Role!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Query {
  aggregateRole(cursor: RoleWhereUniqueInput, orderBy: [RoleOrderByInput!], skip: Int, take: Int, where: RoleWhereInput): AggregateRole!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  role(where: RoleWhereUniqueInput!): Role
  roles(cursor: RoleWhereUniqueInput, orderBy: [RoleOrderByInput!], skip: Int, take: Int, where: RoleWhereInput): [Role!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

type Role {
  createdAt: Timestamp!
  description: String
  id: String!
  name: String!
  users(cursor: UserWhereUniqueInput, orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [User!]
}

input RoleCreateInput {
  createdAt: Timestamp
  description: String
  id: String
  name: String!
  users: UserCreateManyWithoutRoleInput
}

input RoleCreateOneWithoutUsersInput {
  connect: RoleWhereUniqueInput
  create: RoleCreateWithoutUsersInput
}

input RoleCreateWithoutUsersInput {
  createdAt: Timestamp
  description: String
  id: String
  name: String!
}

input RoleOrderByInput {
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
}

input RoleUpdateInput {
  createdAt: Timestamp
  description: String
  id: String
  name: String
  users: UserUpdateManyWithoutRoleInput
}

input RoleUpdateManyMutationInput {
  createdAt: Timestamp
  description: String
  id: String
  name: String
}

input RoleUpdateOneRequiredWithoutUsersInput {
  connect: RoleWhereUniqueInput
  create: RoleCreateWithoutUsersInput
  update: RoleUpdateWithoutUsersDataInput
  upsert: RoleUpsertWithoutUsersInput
}

input RoleUpdateWithoutUsersDataInput {
  createdAt: Timestamp
  description: String
  id: String
  name: String
}

input RoleUpsertWithoutUsersInput {
  create: RoleCreateWithoutUsersInput!
  update: RoleUpdateWithoutUsersDataInput!
}

input RoleWhereInput {
  AND: [RoleWhereInput!]
  createdAt: DateTimeFilter
  description: NullableStringFilter
  id: StringFilter
  name: StringFilter
  NOT: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  users: UserFilter
}

input RoleWhereUniqueInput {
  id: String
  name: String
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

"""
The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

type User {
  createdAt: Timestamp!
  email: String!
  id: String!
  name: String!
  role: Role!
  roleId: String!
}

input UserCreateInput {
  createdAt: Timestamp
  email: String!
  id: String
  name: String!
  role: RoleCreateOneWithoutUsersInput!
}

input UserCreateManyWithoutRoleInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutRoleInput!]
}

input UserCreateWithoutRoleInput {
  createdAt: Timestamp
  email: String!
  id: String
  name: String!
}

input UserFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserOrderByInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  roleId: SortOrder
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: StringFilter
  name: StringFilter
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  roleId: StringFilter
}

input UserUpdateInput {
  createdAt: Timestamp
  email: String
  id: String
  name: String
  role: RoleUpdateOneRequiredWithoutUsersInput
}

input UserUpdateManyDataInput {
  createdAt: Timestamp
  email: String
  id: String
  name: String
}

input UserUpdateManyMutationInput {
  createdAt: Timestamp
  email: String
  id: String
  name: String
}

input UserUpdateManyWithoutRoleInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutRoleInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutRoleInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutRoleInput!]
}

input UserUpdateManyWithWhereNestedInput {
  data: UserUpdateManyDataInput!
  where: UserScalarWhereInput!
}

input UserUpdateWithoutRoleDataInput {
  createdAt: Timestamp
  email: String
  id: String
  name: String
}

input UserUpdateWithWhereUniqueWithoutRoleInput {
  data: UserUpdateWithoutRoleDataInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithWhereUniqueWithoutRoleInput {
  create: UserCreateWithoutRoleInput!
  update: UserUpdateWithoutRoleDataInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: StringFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  role: RoleWhereInput
  roleId: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}
